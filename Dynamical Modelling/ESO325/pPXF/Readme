#Mapa de dispersão de velocidades ESO325

Objetivo: Reproduzir o mapa de dispersão de velocidades da galáxia ESO325 que pode ser visto em
Collet et al 2018, fig. 3.

Data: Cubo de dados do telescópio MUSE, obtido diretamente na plataforma de dados ESO ARCHIVE. Os
dados já são pré-processados pela equipe do ESO, e o tipo de redução feita pode ser visto em 
http://www.eso.org/observing/dfo/quality/PHOENIX/MUSE/processing.html .

Pacotes Python utilizados: MPDAF, Ppxf, Sauron ColorMap.

Descrição dos passos:

1°: Recorte do cubo de dados original. (Arquivo ESO 325.ipynb)
O cubo original foi cortado espacial e espectralmente usando tarefas do mpdaf para se obter um novo
sub-cubo. Isso reduz o tamanho do cubo e permite trabalhar melhor com ele. Além disso, o corte espacial foi feito para se modelar apenas a parte interna ao raio de Einstein. O corte em compriemento de onda é feito para se evitar linhas de absorção da atmosfera e outras emissões/absorções indesejadas. As descrições detalhadas escontran-se no paper citado acima. O resultado do recorte gera um novo cubo (corte.fits) de tamanho 577x30x30, com intervalo em comprimento de onda [4780A à 5500A].

2°: Extração dos Espectros. (Arquivo Extração dos Espectros.ipynb)
Após obter o sub-cubo acima, é necessário extrair o espectro em cada pixel. Como sugere o paper original, para aumentar a razão sinal ruído, os pixels foram binnados em 0.6arcsec pixels. Esse tipo de binnagem aglutina, a partir do primeiro pixel, os 0.6arcsec mais próximos e os transforma todos em um único pixel. Como o subcubo possui 30x30 pixels espaciais, temos um total de 900 pixels individuais espaçados em 0.200 arcsec/px (característica do equipamento). Já que a binnagem será feita em 0.6arcsec (equivalente à 3px), teremos ao final da binnagem um novo cubo com dimensão espacial 10x10, o que irá gerar 100 espectros individuais. A extração desses espectros foi feita com um loop no arquivo  Extração dos Espectros.ipynb e cada espectro salvo na pasta Espectros. Os espectros são salvos com o nome do seu pixel de origem. Por exemplo, o espectro extraído do pixel posição y = 2px e x= 3px é salvo com o nome 2x3.fits.
Os espectros que são binnados e extraídos devem ser extraídos no formato soma(sum), pois isso aumenta o razão sinal ruído, que é nosso objetivo com a binnagem. A opção de extração com média(mean) não é a adquada para este caso.

Nota sobre os espectros: Os espectros do MUSE possuem três extensões. A primeira delas "PRIMARY" possui em seu header as informações de quando o espectro foi obtido. A segunda extensão "DATA" possui os dados obtidos, e em seu header possui as informações sobre os dados. A terceira extensão "STAT" possui a variância dos dados, e em seu header as informações sobre a variância.

3°: Síntese Espectral. (Arquivo Ppxf(vários espectros.ipynb)
Nesta etapa é realizada a síntese espectral com o código Ppxf do Cappellari. O código está bem descrito e seu artigo de 2017 (doi 10.1093/mnras/stw3020) e encontra-se disponível em https://www-astro.physics.ox.ac.uk/~mxc/software/#ppxf . O código disponível no link acima realiza, como exemplo, a síntese para apenas um espectro, ele foi adaptado por mim para realizar a síntese em vários espectros (Ppxf(vários espectros.ipynb), e o código encontra-se com comentários. Ao final da execução, ele gera e salva uma tabela (Output_Ppxf.txt) com as quatro colunas. A primeira é a posição y do pixel, a segunda é a posição x do pixel, a terceira a velocidade associada a este espectro e a quarta a dispersão.

Apenas alguns comentários sobre o Ppxf: 
A variância é igual ao sigma² (desvio padrão ao quadrado).

pp.sol() possui as informações sobre o melhor ajuste do Ppxf, sendo portanto um array. pp.sol[0] é a velocidade, pp.sol[1] é a dispersão, pp.sol[n>1] são os demais momentos descritos no artigo de 2017

O código trabalha no espaço de comprimento de onda logaritmizado, de modo que é necessário informar o comprimento de onda já nestas unidades, ou utilizar a tarefa log_rebin (como é feito aqui). Deve-se atentar que a variância deve sofrer o mesmo processo.

Aqui optou-se por não utilizar a tarefa goodpixels. A tarefa seleciona os melhores pixels para o ajuste, mascarando desta forma algumas possíveis linhas de emissão.

4°: Mapa de Dispersão. (Arquivo DisMap.ipynb)
Nesta etapa é gerado o mapa de dispersão. Para tal, foi utilizada a o pacote Sauron ColorMap, disponível em https://www-astro.physics.ox.ac.uk/~mxc/software/ . O código deve receber três arrays, todos com mesmo tamanho. Um deles com a posição x de cada px, um com a posição y de cada px e um com o valor do px. Neste caso, foi lida a tabela gerada acima e informamos a posição x, y o e valor da dispersão de velocidades em cada posição (x,y). Outros dois tipos de interpolação também foram feitas para que se pudesse comparar. Deve-se notar que, mesmo os mapas não sendo exatemente iguais aos encontrado no artigo de Collet et al., os valores concordam entre si e a região central possui o mesmo tamanho, cerca de 2arcsec (para isso, lembre que cada px do nosso plot possui 0.6arcsec, já que foi binnado desta forma na etapa 2.

